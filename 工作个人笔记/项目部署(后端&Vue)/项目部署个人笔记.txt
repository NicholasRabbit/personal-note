1,打成的war包名就是项目访问的名，是ServletContext的path
  例如， ssm.war
  localhost:8080/ssm

2,Linux下查看Tomcat服务器控制台输出
  tail  -f  /tomcat/.../logs/catalina.out : 可动态查看后台的打印输出

3,如果部署SpringBoot项目，自定义端口要记得Linux设置防火墙例外

4,SpringBoot部署项目使用nuhup命令出现异常：
  忽略输入并把输出追加到"nohup.out"
  解决办法:
  (1) nohup java -jar do_iptable.jar >./log.txt 2>&1 &
  上面表示把项目日志输出到当前目录的log.txt文件里，
  2>&1” 表示 错误和输出都传到nohup.out文件中，默认状态只把输出输出到nohup.out文件中
  nohup 命令默认输出到nohup.out文件中
  (2)执行完此命令会生成一个进程号，
  例如：3054
  (3)查询进程
  netstat -ntlp | grep 3054 
  (4)关闭服务需直接终结进程
  kill 9 3054


5, SSM项目中，如果使用Maven构建项目的话，在pom.xml文件中<plugin>--><path>标签规定项目访问路径
        <groupId>com.thinkgem.jeesite</groupId>
	<artifactId>jeesite</artifactId>
	<version>1.2.7</version>
	<packaging>war</packaging>
	<!-- tomcat7插件 -->
	<plugin>
		<groupId>org.apache.tomcat.maven</groupId>
		<artifactId>tomcat7-maven-plugin</artifactId>
		<version>${tomcat.version}</version> 
		<configuration>
			<port>${webserver.port}</port>
			<path>/${project.artifactId}</path>   
			<uriEncoding>${project.build.sourceEncoding}</uriEncoding>
		</configuration>
	</plugin>
6, 把SpringBoot项目通过Maven达成war包发布的话，SpringBoot内部配置文件application.yml中规定的端口号
   以及项目访问根路径都不起作用了，因为使用的是外部Tomcat服务器，按照外部规定的来。只有达成jar包时，
   使用内嵌Tomcat的情况下才起作用。

7, SpringBoot打成的war包也可以使用 java  -jar demo.war启动,但是要求war包内必须嵌入Tomcat组件

8,SpringBoot一般以jar包的形式部署，一个jar包相当于一个小项目，里面内嵌了tomcat

# 把SpringBoot打成的jar包上传到指定目录，例如/opt/package
  
	(1)在该目录下执行,以下方式shell窗口关闭项目也停止
	java -jar ruoyi-admin.jar > tempLog.txt:生成日志到当前目录下，tempLog.txt自动创建，端口使用： application.yml等文件中的设置 
	java -jar ruoyi-admin.jar  --server.port=9090 > tempLog.txt: 自定义端口，注意要在Linux防火墙设置9090例外，否则无法访问


	(2)后台继续运行项目写法：
	nohup java -jar ruoyi-admin.jar  --server.port=9090 > tempLog.txt : 定义端口号，并在后台运行，日志输出到tempLog.txt
	或 ： nohup java -jar ruoyi-admin.jar  > log.out & tail -f nohup.out :发布后查看日志

	2,防火墙设置自定义的9090例外，否则外部无法访问
	firewall-cmd --zone=public --add-port=9090/tcp --permanent
	firewall-cmd --reload    #重启firewall