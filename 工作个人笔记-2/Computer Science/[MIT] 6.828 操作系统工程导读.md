##  [MIT] 6.828 操作系统工程导读

##  PC Bootstrap & Compiler Principles

本文是计算机科学基础类内容，目的是为软件方向的同学提供一个学习 roadmap 性的指导材料。很多准备入门计算机技术的同学缺少引导性的资料，可能边学习环境配置也是个不小的挑战。那么希望通过本文，减少大家走弯路的可能。



- 6.828: Operating System Engineering [https://pdos.csail.mit.edu/6.828/2018/schedule.html](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/schedule.html)
- Modern Compiler Implementation in C/ML/Java by Andrew W. Appel [https://2lib.org/s/Modern%20Compiler%20Implementation](https://link.zhihu.com/?target=https%3A//2lib.org/s/Modern%20Compiler%20Implementation)
- Modern Compiler Implementation in C/ML/Java [普林斯顿编译入门课] [https://www.cs.princeton.edu/~appel/modern/](https://link.zhihu.com/?target=https%3A//www.cs.princeton.edu/~appel/modern/)
- Engineering a Compiler - Keith Cooper, Linda Torczon [编译原理入门] [https://2lib.org/book/1306354/a94f18](https://link.zhihu.com/?target=https%3A//2lib.org/book/1306354/a94f18)
- Compilers: Principles, Techniques and Tools [编译原理龙书] [https://2lib.org/s/?q=Compilers%3A+Principles](https://link.zhihu.com/?target=https%3A//2lib.org/s/%3Fq%3DCompilers%3A%2BPrinciples)
- Compilers: Principles, Techniques and Tools [斯坦福龙书课程] [https://suif.stanford.edu/dragonbook/](https://link.zhihu.com/?target=https%3A//suif.stanford.edu/dragonbook/)
- How Compilers Work by Albert Stec [https://www.baeldung.com/cs/how-compilers-work](https://link.zhihu.com/?target=https%3A//www.baeldung.com/cs/how-compilers-work)

麻省理工大学 Massachusetts Institute of Technology  拥有全球最顶尖的计算机教学系统，该校的计算机学院科学与人工智能研究中心，并行分布式操作系统小组的在线课程资源 6.828: Operating  System Engineering 是非常棒的，可以说就这份在线资源胜过国内一大批高校的计算机课程。

- [MIT] 6.828: Operating System Engineering [https://pdos.csail.mit.edu/6.828/2018/schedule.html](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/schedule.html)
- PC Assembly Language Book [https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf)
- Intel® 64 and IA-32 Architectures Software Developer Manuals [https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html](https://link.zhihu.com/?target=https%3A//software.intel.com/content/www/us/en/develop/articles/intel-sdm.html)
- 80386 Programmer's Reference Manual [https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm)
- Lab 1: Booting a PC [https://pdos.csail.mit.edu/6.828/2018/labs/lab1/](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/labs/lab1/)
- Lab 2: Memory Management [https://pdos.csail.mit.edu/6.828/2018/labs/lab2/](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/labs/lab2/)
- Lab 3: User Environments [https://pdos.csail.mit.edu/6.828/2018/labs/lab3/](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/labs/lab3/)
- Lab 4: Preemptive Multitasking [https://pdos.csail.mit.edu/6.828/2018/labs/lab4/](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/labs/lab4/)
- Lab 5: File system, Spawn and Shell [https://pdos.csail.mit.edu/6.828/2018/labs/lab5/](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/labs/lab5/)
- Lab 6: Network Driver (default final project) [https://pdos.csail.mit.edu/6.828/2018/labs/lab6/](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/labs/lab6/)
- Lab 7: Final JOS project [https://pdos.csail.mit.edu/6.828/2018/labs/lab7/](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/labs/lab7/)
- 实验代码仓库 [https://pdos.csail.mit.edu/6.828/2018/jos.git/](https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/jos.git/)

当年在学习汇编时是 2004 年左右，当时不会用虚拟技术，只能用 DOS 或都反汇编研究 C/C++ 生成的汇编指令，后来也花了大量去研究 Intel x86 指令系统。

- 那年声明理解不了定义与初始化(二) [https://blog.csdn.net/WinsenJiansbomber/article/details/50646981](https://link.zhihu.com/?target=https%3A//blog.csdn.net/WinsenJiansbomber/article/details/50646981)
- 反汇编基本原理与x86指令构造 [http://blog.csdn.net/winsenjiansbomber/article/details/27253577](https://link.zhihu.com/?target=http%3A//blog.csdn.net/winsenjiansbomber/article/details/27253577)
- 深入x86的内存寻址 [http://blog.csdn.net/winsenjiansbomber/article/details/24243843](https://link.zhihu.com/?target=http%3A//blog.csdn.net/winsenjiansbomber/article/details/24243843)
- 《深入x86的内存寻址》I/O 外设硬件开发举例一 [http://blog.csdn.net/winsenjiansbomber/article/details/24395073](https://link.zhihu.com/?target=http%3A//blog.csdn.net/winsenjiansbomber/article/details/24395073)
- Codeblocks GDB调试器设置与使用 [http://blog.csdn.net/winsenjiansbomber/article/details/50636911](https://link.zhihu.com/?target=http%3A//blog.csdn.net/winsenjiansbomber/article/details/50636911)
- Intel 80386 Reference Programmer's Manual [http://download.csdn.net/detail/winsenjiansbomber/7281997](https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/winsenjiansbomber/7281997)

计算机从加电启动那一刻，就开始了无休止的执行各种指令，解析计算启动到操作系统加载这一过程，通常需要使用汇编语言来描述才更贴切 CPU 的工作原理。

这个课程需要你对计算机体系架构有一定认识，即计算机的结构：

- CPU 负责指令执行与控制；
- MCH - Memory Controller Hub 芯片连接高速部件，如内存、显卡；
- Memory 内存通过地址总线直接与 CPU 相连，并受控于它，通过数据总线与其传输数据；
- ICH - I/O Controller Hub 芯片连接各种外部低速输入输出设备，如鼠标、键盘、硬盘、 PCI 外部互连总线扩展设备。

整个系统中，CPU 是运行速度最快的，现代的 CPU 主频随便都 GHz 为单位，其次，是与 CPU  直接相连的内存和显卡，准确来讲，中间通过内存控制芯片。最后，才通过 ICH  芯片与各种低速设备连接，这些低速设备又使用同的接口规范，如硬盘一盘通过 ATA 或较新的 SATA，**Serial** Advanced Technology Attachment，或者声卡连接通过 PIC - Peripheral Component Interconnect。

因为，通常的在计算机架构图中，CPU 在最上面，其次是 MCH 芯片，最下面是 ICH 芯片和各种低速 I/O 设备，所以两个主要芯片又俗称为北桥芯片、南桥芯片。对于 CPU  来说，所有接连的都属于 I/O  设备，指令需要从内存中输入，处理得到的数据可以写入内存、硬盘，或者输出到显卡，最终在输出到显示器，又或者是其它设备。

```text
                       +------------------+
                       | ======CPU======= |
                       +--------+---------+
                                |
                   +------------+--------------+
    +-----+        |                           |    +------+
    | AGP +--------+ MCH(Memory Controller Hub)+----+Memory|
    +--+--+        |                           |    +------+
       |           +------------+--------------+
+------+-------+                |
|              |   +------------+--------------+     +-----+
|   Display    |   |                           |     |     |
|              |   | ICH(I/O Controller Hub)   +-----+   -->
+--------------+   |                           |     | PCI |
                   +---+--------+-------+----+-+     |   -->
                       |        |       |    |       |     |
          +----------+ |   +----+---+   |  +-+-----+ |   -->
      +---+   USB    +-+   |  ATA   |   |  |Network| |     |
      |   +-------+--+     +----+---+   |  +-------+ |   -->
      |           |             |       |            |     |
  +---+---+  +----+---+  +------+--+ +--+--------+   |   -->
  | Mouse |  |Keyboard|  |Hard Disk| | Flash BIOS|   |     |
  +-------+  +--------+  +---------+ +-----------+   +-----+

ASCII Flow Draw by https://asciiflow.com/
```

而理解 PC 引导过程，和操作系统原理，是软件开发中两个特别基础又重要的知识。MIT 的网上课程有相应的实验代码，可以使用 Git 工具下载，并且通过 QEMU Emulator 及 GNU debugger (GDB) 这些工具实现内核代码的运行调试。

课程提供了用于实验的系统内核 JOS，可以通过以下命令克隆代码仓库：

```text
git clone https://pdos.csail.mit.edu/6.828/2018/jos.git
```

使用 Linux 系统，可以很方便地安装免费的 GCC 编译器套件，对 JOS 进行编译，并且通过 QEMU 模块器加载进行调试，配合调试工具可以很明了地认识内核代码在 PC 引导过程所起的作用。

课程将实验分成三个部分：

- 熟悉 x86 架构的 CPU 指令及汇编语言，熟悉 QEMU x86 emulator 的使用，PC bootstrap 主机加电引导过程。
- 实验 6.828 课程用的内核提供的 boot loader 程序，在代码仓库的 boot 目录下可以找到。
- 最后，深入研究为本课程服务的 JOS 内核初始模板，可以在 kernel 目录中找到。

掌握硬件基础后，可以学习更深层的操作系统实现细节，或者是编译器原理，所以程序几乎都是由编译器编译生成的可执行文件，纯粹手写机器指令的方式是不太现实的，即使是使用汇编语言，通常也只有在底层系统中使用，比如嵌入式开发的系统底层处理。

一个编译器的实现步入多个处理流程，可以分成以下几个阶段：

- Lexical analysis
- Syntax analysis
- Semantic analysis
- Intermediate code generation
- Optimization
- Code generation

为了简化编译原理的学习，普林斯顿大学的现代编译器实现课程中推荐使用 SPIM 模拟器，它可以模拟最简单的指令集，MIPS instruction set，注意 MIPS 也表示百万指令每秒，MIPS 也是设计这种指令集的公司，它们完全不同意思。

MIPS 属于精简指令集计算机架构，使用 MIPS 指令集也最简单，只有几十条指令，但是包含完整的算术指令、逻辑指令、流程控制指令、数据读写指令，及其它功能性指令。

为精简指令集生成代码，要比 Pentimu 这种使用复杂指令的系统要简单。同时，使用 RISC 指令可以更好帮助学生掌握入门级的计算机体系结构方面的知识。

但是这通常需要一块有这类芯片的开发板，而大多数学生的个人电脑使用的 x86-64 架构 CPU。那么使用软件模拟器就是一个解决办法，SPIM simulator 就可以用在学习 MIPS  汇编语言上，并且它可以运行在 Pentium PC 主机上，使用 Windows 或 Unix 系统的工作站上运行。升级版本，QtSpim  使用了 Qt Gui 图形库，使用起来更加方便。目前最新版本 SPIM Version  9.1.20，安装后即可以打开编写好的汇编语言代码模拟执行，软件还附带帮助文档，Assemblers, Linkers, and the  SPIM Simulator。

当然，如果能力可以，直接上 Intel 80386 CPU 也是可以的，并且英特尔提供了丰富的参考资料。

现在，Windows 10 WSL 子系统也可以安装 Linux 进行开发，而不必另外安装虚拟机来运行 Linux 系统。

CPU 体系架构很多，如常见的 ARM、X86/Atom、MIPS、PowerPC，除此外还许多其它架构如 Atmel 的 AVR 架构，Sun 的 Ultra Sparc 架构等。

CPU 的指令集也很多，但是基本可以分为两类，它们差别主要体现在指令与数据处理上：

- CISC - Complex Instruction Set Computer 复杂指令集，具有大量的指令和数据寻址方式；
- RISC - Reduced Instruction Set Computer 精简指令集，仅处理寄存器中的数据；

但主要 PC 结构或 CPU 架构分为两种：

-  冯·诺依曼体系结构，对应 CISC 指令系统，如 x86、x86-64、Atom，常用于台式机或服务器：

1. **数据与指令都存储在同一存储区中，取指令与取数据利用同一数据总线。**
2. 被早期大多数计算机所采用。
3. ARM7 是冯诺依曼体系结构简单，但速度较慢，取指不能同时取数据。

-  哈佛体系结构，对应 RISC 指令系统，如嵌入式中流行的 ARM、PowerPC、MIPS、Sparc、Alpha，常用于工控、移动设备：
   

1. **程序存储器与数据存储器分开。**
2. 提供了较大的存储器带宽，各自有自己的总线。
3. 适合于数字信号处理。
4. 大多数 DSP 都是哈佛结构。
5. ARM9 是哈佛结构，取指和取数在同一周期进行，提高速度，改进哈佛体系结构分成三个存储区：指令区、数据区、共用区。

## QEMU simulator

- JSLinux - Operating Systems in your browser! [https://bellard.org/jslinux/](https://link.zhihu.com/?target=https%3A//bellard.org/jslinux/)
- QEMU - a generic machine emulator and virtualizer [http://qemu.org/](https://link.zhihu.com/?target=http%3A//qemu.org/)
- SPIM: A MIPS32 Simulator [http://spimsimulator.sourceforge.net](https://link.zhihu.com/?target=http%3A//spimsimulator.sourceforge.net)
- WSL - Windows Subsystem for Linux & Xfce Desktop [https://www.jianshu.com/p/2dd28c78355a](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/2dd28c78355a)
- DJGPP - 32-bit DOS C/C++ compiler [http://www.delorie.com/djgpp/](https://link.zhihu.com/?target=http%3A//www.delorie.com/djgpp/)
- WinWorld from the past, to the present, for the future [https://winworldpc.com/home](https://link.zhihu.com/?target=https%3A//winworldpc.com/home)

另一个更强大的模拟器 QEMU 是 Fabrice Bellard 大神的作品，开源的虚拟机，被各大行业用来做底层开发研究用的神器，它真实地模拟出你的硬件环境，不管是 MIPS 还 ARM 都不在话下。

QEMU 可以运行在多种平台下，在 Windows 系统可以直接下载可执行程序，安装完成后，会有多个模拟器不同的后缀表示该模拟器的实现的目标 CPU 架构，比如：

```text
qemu-system-mips.exe
qemu-system-mips64.exe
qemu-system-mips64el.exe
qemu-system-mips64elw.exe
qemu-system-mips64w.exe
qemu-system-mipsel.exe
qemu-system-mipselw.exe
qemu-system-mipsw.exe
```

注意后缀，64 表示 64 bit 系统，el 表示 Intel Little-Endian，没有后缀的 `qemu-system-mips` 表示 A generic ISA PC-like machine。

有了这些模拟，还需要 Linux 内核映像，下载现成的 PC hard disk image，官方文档中提供相应的模拟器镜像下载。

```text
generic_nano32r6el_page64k_dbg.config
generic_nano32r6el_page64k_dbg.itb
generic_nano32r6el_page64k_dbg.xz
```

执行以下命令加载映像：

```text
qemu-system-mipsel linux.img
```

以上命令加载内核映像 linux.img，正常情况应该可以看到 Linux 引导过程。模拟器提供丰富的命令行参数，根据需要指定，通常是通过指定配置文件进行配置，具体参考文档。

其它命令使用参考：

```text
qemu-system-mipsel -cpu I7200 -kernel <kernel_image_file> \
    -M malta -serial stdio -m <memory_size> -hda <disk_image_file> \
    -append "mem=256m@0x0 rw console=ttyS0 vga=cirrus vesa=0x111 root=/dev/sda"

qemu-img create myimage.img mysize

# automatically create a virtual FAT disk image from a directory tree.
qemu-system-x86_64 linux.img -hdb fat:/my_directory

# Floppies can be emulated with the :floppy: option:
# A read/write support is available for testing (beta stage) with the :rw: option:
qemu-system-x86_64 linux.img -fda fat:floppy:/my_directory
qemu-system-x86_64 linux.img -fda fat:floppy:rw:/my_directory

# boot from a remote Fedora 20 live ISO image
qemu-system-x86_64 --drive media=cdrom,file.driver=file,file=/nanoMIPS/alpine-standard-3.13.5-x86_64.iso,readonly=on

qemu-system-x86_64 --drive media=cdrom,file=https://archives.fedoraproject.org/pub/archive/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly=on

qemu-system-x86_64 --drive media=cdrom,file.driver=http,file.url=http://archives.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly=on
```

和 GDB 进行远程调试，使用 -s 和 -S 激活侦听来自 gdb 的 TCP 1234 端口的连接，指定 gdbstub connection，使用 -gdb dev 参数：

```text
# QEMU will launch but will silently wait for gdb to connect.
qemu-system-x86_64 -s -S -kernel bzImage -hda rootdisk.img -append "root=/dev/hda"

# Then launch gdb on the ‘vmlinux’ executable:
> gdb vmlinux
(gdb) target remote localhost:1234
(gdb) c
```

QEMU 启动后会有 monitor 命令窗口，可以向 QEMU emulator 发送命令，如：

- 插入或弹出媒体，如 CD-ROM 或软盘，如 `change ide1-cd0 /path/to/some.iso`，弹引出命令 `eject [-f] device`。
- 冰冻或解冻虚拟机，或者从保存状态到文件，以及从文件还原状态。
- 探测虚拟机状态而不需要外部调试器。

```text
qemu-system-aarch64 -M virt,virtualization=true -cpu cortex-a57 -smp 4 -m 4096 ^
-device qemu-xhci -device usb-kbd -device usb-tablet ^
-drive file=disk.qcow2,if=virtio ^
-drive file=win.iso,media=cdrom,if=none,id=cdrom -device usb-storage,drive=cdrom ^
-bios QEMU_EFI.fd -device ramfb ^
-drive file=vars-template-pflash.raw,if=pflash,index=1
```

经历多年的发展，从 2005 年，Bellard 发布了 QEMU 开源虚拟机技术，到今天的 QEMU 6.0，它真正做到了 Run operating  systems for any machine, on any supported  architecture。这是个爆炸性的项目，现在众多底层开发人员已经离不开它，可用来研究系统底层，学习嵌入式开发，相当的强大。

```text
qemu-0.9.1.tar.xz   2017-02-07 09:19    1.8M
...
qemu-6.0.0.tar.xz   2021-04-29 15:29    102M
```

要研究原代码，可以通过 Git 获取指定的版本分支：

```text
$ git init
$ git remote add origin git@github.com:qemu/qemu
$ git remote show origin
$ git fetch origin stable-0.10
$ git checkout -b stable-0.10 origin/stable-0.10
```

## Assembly Pre-basic

从编译原理上去理解汇编语言，会比较容区分机器指令和伪指令，Instruction vs Directive，伪指令也可以称为伪代码 Presudocode。

为什么一定要使用伪代码？伪代码很好地平衡了自然语言的易理解性、非形式所带来的模糊性与代码的精确性之的矛盾。伪指令对编译器具有指导作用，去做一些不是指令做的工作，也更便于人类阅读理解。

在学习汇编语言之前，除了认识 CPU 结构的重要性，它主要是执行指令、寻址获取数据、输出结果，另外对内存模型的深刻认识也必需重视。因为，程序在执行前，需要从硬盘读取送往内存指定的区域，然后必需让 CPU 知道从什么地址开始执行代码。

内存模型，Memory Model 即可以简单理解为内存的数据结构，从 CPU 和内存硬件的发展过程中，内存模型是有差异的。早期，硬件技术不够成熟，内存容量小也慢，CPU 的寻址能力也弱。

以划时代的 Intel 8086 为例，它拥有四个 16bit 通用寄存器，四个 16bit 索引寄存器，后缀 x 表示对早期 8 位机的寄存器的扩展：

- AX - Accumulator，累加器，用于累加计算，并保存计算结果，使用频度最高
- BX - Base Register，基址寄存器，常存放存一个内存地址
- CX - Count Register，计数器，计数时自动记录次数
- DX - Data Register，数据寄存器，存放数据
- SI - Source Index，源变址寄存器，常保存存储单元地址
- DI - Destination Index，目的变址寄存器，常保存存储单元地址
- BP - Base Pointer，基址指针寄存器，表示堆栈区域中的基地址
-  SP - Stack Pointer，堆栈指针寄存器，指示堆栈区域的栈顶地址
   
-  IP - Instruction Pointer，专用的指令指针寄存器，指示要执行指令所在内存地址；
   
- FLAG 标志寄存器记录 CPU 执行指令后的状态，比如出现溢出表示寄存器容量不足以保存计算结果；
- CS - Code Segment 代码段寄存器；
- DS - Data Segment 数据段寄存器；
- SS - Stack Segment 堆栈段寄存器；
- ES - Extra Segment 附加段寄存器；

通常，16 bit 的地址总线可以寻址 2^16 = 64KB 内存空间，但是 8086 CPU 可以通过组合内存区段寄存器、索引寄存器，提供额外的 4 bit 寻址能力，其中交叠 12bit，总共获得 20 bit 寻址能力即 1MB。

```text
          +-------------------------------+
          |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5| Index Register(Offset Address)
          +-------------------------------+
  +-------------------------------+
  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|       Segment Register(Base Address)
  +-------------------------------+
  =========================================
  +---------------------------------------+
  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|  Physics/Effective Address
  +---------------------------------------+
```

这种方式只是早期硬件技术限制采用的一种硬件 hack，称为 A20 Gate，通过不是那么好用的方式实现了更大的寻址能力。

不管如何，内存总是不够用的，BIOS 需要内存，各种设备需要内存，CPU 需要通过内存与外设进行数据交流。而操作系统更需要内存，所以需要对有限的内存进行最合理的应用，这就是内存模型的基本概念。

通常，最低层的设备使用内存地址最小的部分，通常 BIOS 程序就是最低的内存区域，而程序运行则放在高地址的内存区。

以下是 MIPS 架构和 PC x86 架构的内存模型对比：

```text
  +----------+ 0x7FFFFFFF               +------------------+  <- 0xFFFFFFFF (4GB)
  | frame... | stack segment            |      32-bit      |
  |          | |                        |  memory mapped   |
  |          | |                        |     devices      |
  |          | V                        /\/\/\/\/\/\/\/\/\/\
  |          |                          /\/\/\/\/\/\/\/\/\/\
  +----------+                          |      Unused      |
  | Dynamic  |                          +------------------+  <- depends on amount of RAM
  | Static   | Data Segment             | Extended Memory  |
  +----------+ 0x10000000               +------------------+  <- 0x00100000 (1MB)
  |          |                          |     BIOS ROM     |
  |          |                          +------------------+  <- 0x000F0000 (960KB)
  |          |                          |  16-bit devices, |
  +----------+   0x400000               |  expansion ROMs  |
  | Reserved |                          +------------------+  <- 0x000C0000 (768KB)
  +----------+ 0x00000000               |   VGA Display    |
                                        +------------------+  <- 0x000A0000 (640KB)
                                        |    Low Memory    |
                                        +------------------+  <- 0x00000000
```

MIPS 处理器系统中，将内存划分为 3 个部分：

- 第一部分从最低内存地址开始，以 0x400000 为起点，作为代码段，保存代码指令。
- 第二部分从代码段之上开始，细分为 Static data 区和，起始地址为 0x10000000。
- 第三部分从最高内存地址开始往下作为调用栈内存空间 stack segment。

注意，可以看到最高内存地地址 0x7FFFFFFF 并不是代表真实内存有这么多，它是虚拟内存空间，通过硬件映射后，才访问到真实的内存地址。

在汇编程序中，通过 `.text` 汇编指令就可以指示编译器，在编译进将这部分生成的指令存到代码段内存空间，准确地说是编译器保存了相关信息，在执行程序时，由程序加载器负责将其传送到代码段内存中。

静态数据 Static data 表示那些在编译阶段就可以确定在整个程序运行期间都有效的数据，也就是数据生命周期保持和程序运行周期一样长，比如，C/C++ 中的全局变量。

Stack 是个很重要的内存空间，它是在硬件层次上实现的数据结构，Last-in First-out，后进先出，先进后出，CPU 通常都提供压栈和出栈指令，`**PUSH**` & `**POP**`。在高级语言中或汇编语言中，是有函数调用的这一功能的，procedure call。从 A 函数调用 B 函数，执行完后还要回来 A 函数按原位置继续执行。

那么在调用 B 函数前，就需要将当前执行的指令所在的内存地址，即 PC 寄存器的内容记录下来，等调用函数后返回时再恢复。这就叫做现场保护，要保护的还包括使用到的其它寄存器。

而将数据保存在什么地方呢？这就需要使用 Stack 的内存空间了，CPU 通常都提供压栈和出栈指令，PUSH &  POP，将需要保护的数据暂存于栈内存。每次函数调用产生的现场保护动作，都会有相应的 Stack 数据产生，这个动作产生的数据称为  frame，就像电影一帧一帧地记录数据。

例如，对于一个用于对 100 以内自然数求和的程序两个版本，汇编语言中使用：

- `.text` 指示符号表示这里是代码区，编译后得到的程序也会由此开始执行。
- `.align` 表示数据在内存中的对齐行为，编译器需要根据指定的对齐参数来调整那些需要进行内存地址对齐数据。
- `.global` 定义全局符号，即从其它文件可以引用的符号 `main`，对应于 C/C++ 中的主函数，注意区别 `main:` 是行标签。

汇编语言实现：

```js
.text
        .align 2
        .globl main
main:
        subu $sp, $sp, 32
        sw $ra, 20($sp)
        sd $a0, 32($sp)
        sw $0, 24($sp)
        sw $0, 28($sp)
loop:
        lw $t6, 28($sp)
        mul $t7, $t6, $t6
        lw $t8, 24($sp)
        addu $t9, $t8, $t7
        sw $t9, 24($sp)
        addu $t0, $t6, 1
        sw $t0, 28($sp)
        ble $t0, 100, loop
        la $a0, str
        lw $a1, 24($sp)
        jal printf
        move $v0, $0
        lw $ra, 20($sp)
        addu $sp, $sp, 32
        jr $ra
        .data
        .align 0
str:
        .asciiz "The sum from 0 .. 100 is %d\n"
```

C/C++ 语言实现：

```js
#include<stdio.h>
int
main (int argc, char *argv[])
{
  int i; int sum = 0;
  for (i = 0; i <= 100; i = i + 1) sum = sum + i * i;
  printf ("The sum from 0 .. 100 is %d\n", sum);
}
```

安装 QtSpim 模拟器后，可以直接运行演示程序，打印 Hello World：

```js
# helloworld.s
#
# Print out "Hello World"
#
        .data
msg:    .asciiz "Hello World"
        .extern foobar 4

        .text
        .globl main
main:   li $v0, 4       # syscall 4 (print_str)
        la $a0, msg     # argument: string
        syscall         # print the string
        lw $t1, foobar

        jr $ra          # retrun to caller
```

代码一般我会尽量少贴，因为没有用，代码只有自己去阅读去理解才有意义。

![img](https://pic3.zhimg.com/v2-8874716a1bcc4e9ccc28d0c7a60826fa_r.jpg)

## Alpine Linux

![img](https://pic2.zhimg.com/v2-3c95926d14ce993bc45ead0687ede01d_r.jpg)


 