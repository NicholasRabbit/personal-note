### 1，Tocmat中配置虚拟路径与真实路径映射，保存图片

web项目中一般不把上传的图片保存到数据库，也不保存到项目目录下，而是保存到本地磁盘下，然后设置url路径和本地磁盘路径的映射，在Tomcat的conf/server.xml文件中进行配置

```txt
首先找到tomcat目录下conf目录下的server.xml文件，在server.xml文件中找到<Host></Host>；
然后在其中加上这<Context path="/uploadfile" docBase="D:\File\images"></Context>

上面配置完成后，tomcat在的请求一般为：http://localhost:8080/uploadfile/abc.jpg。配置完重启之后，该请求自动跳转到物理路径D:\File\image下查找。会访问本机的D:\File\imager\abc.jpg。
```

这样只需把数据库表中的，例如:path字段存储的相对路径值传到前端即可，前端把这个路径拼接到url上即可进行访问。**注意：这里设置的"Context path" 和application.yml里的不一样，访问图片是按照这个跟路径**

详见：工作个人笔记-2\项目笔记\tomcat配置虚拟路径上传文件、图片.docx  项目中图片的存储路径设置.docx 

后期写个例子验证

这样做的目的是减少数据库的容量，直接把图片保存到服务器的本地磁盘上了。

### 2，煤电平台保存图片也是按照 1 中的方法

数据库vehicles_imgs里只是保存的相对路径，共前端的url拼接后访问的

```html
<!--静态页面的路径-->
<img src = "/profile/upload/2021/08/21/ac6d94dd-4740-42e5-93a9-bc9f3a0911b4.jpg"></img>
访问路径：http://localhost:8080/profile/upload/2021/08/21/ac6d94dd-4740-42e5-93a9-bc9f3a0911b4.jpg
```

```java
//AppApiController.java里的上传图片方法 
private int uploadFiles(String foreignId,String serverType,String userId,List<MultipartFile> files){
        int num = 0;

        for(int i = 0 ; i < files.size() ; i++ ){
           try {
               String fileName = FileUploadUtils.upload(files.get(i));   //这里实际是真正上传图片到服务器
               VehiclesImgs vehiclesImgs = new VehiclesImgs();
               vehiclesImgs.setId(IdUtils.fastSimpleUUID());
               vehiclesImgs.setForeignId(foreignId);
               vehiclesImgs.setServerType(serverType);
               vehiclesImgs.setImgUrl(fileName);  //这里只是设置保存的相对路径，供前端访问用的
               vehiclesImgs.setCreateBy(userId);
               num += vehiclesImgsService.insertVehiclesImgs(vehiclesImgs);  //插入表内的只是路径字符串，并不是图片本身
           } catch (IOException e) {
               e.printStackTrace();
           }
       }

        return num;
    }
```

### 3, App端使用token认证的流程

(1)首先用户输入用户名密码验证通过后，会随机生成一个token, 它有个有效期，用户每次请求后端接口会在headers里带上这个token

详见：优车管postman登录app端步骤.docx

```java
//coal项目
@Controller
public class SysLoginController extends BaseController{
String token = IdUtils.fastSimpleUUID();
        user.setToken(token);
    return AjaxResult.success("登录成功",user);  //user含有token信息会传给前台
}    
```

(2)App端把后端传来的token保存到本地，每次请求就会带上这个token

![1645493354033](note-images/1645493354033.png)

(3)后端接收到这个token会在Filter里进行验证，对比与之前传过去的token是否相同，验证通过后才返回数据

```java
//coal项目
public class AppApiFilter  implements Filter {

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

        HttpServletRequest httpRequest = (HttpServletRequest)servletRequest;
        HttpServletResponse httpResponse = (HttpServletResponse)servletResponse;

        String mpToken = httpRequest.getHeader("mpToken");

        if(StringUtils.isEmpty(mpToken)){
            httpResponse.getWriter().println(JSONObject.valueAsStr(AjaxResult.error()));
        }else {
            Object obj = JedisUtils.getObject(mpToken);
            if(null != obj){
                filterChain.doFilter(httpRequest, httpResponse);
            }else {
                httpResponse.getWriter().println(JSONObject.valueAsStr(AjaxResult.error()));
            }
        }

    }

```

### 4, @RequestMapping注解也可以获取application.yml里的注入

```java
@Controller
@RequestMapping(value = "${adminPath}")  //这里在yaml文件中注入值
public class LoginController extends BaseController {   }
```

### 5, 页面图片小图展示的做法

设置好css样式即可，后期点击放大在加事件即可。

```html
<img src="http://localhost:8080/files/qq.jpg"  style="width:40px;height:40px;">图片QQ</img>  <br><br>

   <img src="http://localhost:8080/files/scenery.jpg" style="width:40px;height:40px;">风景</img>
```

### 6, 查看前端请求的后端接口地址

一般headers里有，如果headers里不对，则在Payload里可查看到

![1646187201545](note-images/1646187201545.png)

### 7,优车管App中token的用法

首先用户登陆后，后台会根据用户名等信息从数据库中查出用户全部信息；

然后生成一个uuid作为token, 把token当作key,  用户信息对象user当作value存到redis里；

把token返回前端；

本次会话访问接口都带着token，查询数据时就从redis里获取对应用户，再查该用户的的其它信息；

代码见:  coal 项目的SysLoginController.java   AppApiController.java

### 8, 使用HttpServletRequest接收上传的文件，并保存

![1646723639992](note-images/1646723639992.png)

```java
  //11,保存
    @ResponseBody
    @RequestMapping("/saveOrder")
    public ResultModel savePhoto(HttpServletRequest request) {

        ResultModel result = new ResultModel("0","测试");

        //新建CommonsMultipartResolver
        CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver(request.getSession().getServletContext());
        //上传文件地址
        String destPath = "E:\\localfile\\recycle";
        String imgPath = "";
        //判断请求里是否含有MultipartFile
        if (multipartResolver.isMultipart(request)) {
            //multiRequest是个Map,前端一个key对应一个multipart,传多个文件须有多个key, 名称不限，这里会自动解析
            MultipartHttpServletRequest multiRequest = (MultipartHttpServletRequest) request;
            Iterator<String> iter = multiRequest.getFileNames();
            //判断并保存到服务器本地
            while (iter.hasNext()) {
                MultipartFile multipartFile = multiRequest.getFile(iter.next());
                String dir = destPath + File.separator + multipartFile.getOriginalFilename();
                File file  = new File(dir);
                try {
                    multipartFile.transferTo(file);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
//        imgPath = imgPath.substring(0, imgPath.length() - 1);

        return result;
    }
```

### 9, SpringBoot项目设置访问图片路径映射

##### 第一种方式：

  编写一个WebMvcConfig类继承WebMvcConfigurerAdapter： 

addResourceHandler("/upload/**")配置的虚拟路径
 addResourceLocations(“file:D:/SchoolShop_IMG/upload/”);配置的映射路径 

注意：

1. file： 前缀不能丢。
2. 分隔符一定要用 / 。
3. 如果有配置server.servlet.context-path: /demo ，访问图片时一定要加上

```java
@Configuration
public class WebMvcConfig extends WebMvcConfigurerAdapter {
    @Autowired
    private FileUploadProperteis fileUploadProperteis;
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(fileUploadProperteis.getStaticAccessPath())
                .addResourceLocations("file:" + fileUploadProperteis.getUploadFolder() + "/");
    }

}
```

**注意：**上面设置后，原来SpringBoot项目默认设置resources目录静态路径static等都失效了，

需要在addResourceLocations(String ...)添加参数设置，使原先的static, public默认路径等还有效，因为它们里放着js,css等文件

```java
@Configuration
public class WebUrlMvcConfig extends WebMvcConfigurerAdapter {
    @Autowired
    private WebConfigProperties webConfigProperties;
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(webConfigProperties.getAccessPath())
                .addResourceLocations("file:" + webConfigProperties.getBaseDir() + "/" , "classpath:/static/","classpath:/public/");
    }
    //addResourceLocations(String ...),形参是可变参数，多个路径用逗号“，”隔开
}
```



##### 第二种方式：再application.yml文件里设置

https://blog.csdn.net/qq_31762741/article/details/121174900

```yml
# 应用服务 WEB 访问端口
server.port=8080
# 项目静态资源路径,可以不写默认为/**
# spring.mvc.static-path-pattern=/**
# 将项静态目资源路径映射到系统资源路径下
spring.resources.static-locations=file:H:\\AFile

====
spring.resources.static-locations=file:G:\\AFile,file:H:\\AFile

```

### 10, SpringBoot项目自定义配置类，出现异常

Web模块Application.java主启动类，启动报异常

异常名称：Error creating bean with name 'resourceHandlerMapping

代码：项目是SpringBoot多个模块

出错原因，这个个人手写配置类是给Weixin模块用的，但是开始放到了核心模块core里

解决办法：把这个自定义配置类放到Weixin模块即可

```java
//SpringBoot设置虚拟路径映射Tomcat磁盘路径
@Configuration
public class WebUrlMvcConfig extends WebMvcConfigurerAdapter {
    @Autowired
    private WebConfigProperties webConfigProperties;
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(webConfigProperties.getAccessPath())
                .addResourceLocations("file:" + webConfigProperties.getBaseDir() + "/");
    }
}
```

```yaml
file:
  enabled: true
  #url映射路径
  accessPath: /wxfiles/**
  #本地测试磁盘路径
  baseDir: E:\\localfile\\recycle
```

### 11,  idea使用maven可不设置Delegatge  IDE build/run  to Maven

执行 mvn  clean 以后 ，直接启动，反而可以自动编译，不用compile,  install了

### 12, “<“packaging>pom</packaging”>”的含义

一般在SpringBoot项目的根目录下的pom.xml里进行这样的设置

（1）打包成pom表示它生成的构件只是它本身， 没有代码需要测试或者编译，也没有资源需要处理。打包类型为POM的项目的默认目标 ；

（2） pom 项目里没有java代码，也不执行任何代码，只是为了聚合工程或传递依赖用的。

 （3） 配置<packaging>pom</packaging>的意思是使用maven分模块管理，都会有一个父级项目，pom文件一个重要的属性就是packaging（打包类型），一般来说所有的父级项目的packaging都为pom，packaging默认类型jar类型，如果不做配置，maven会将该项目打成jar包。  