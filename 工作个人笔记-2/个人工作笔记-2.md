### 1，Tocmat中配置虚拟路径与真实路径映射，保存图片

web项目中一般不把上传的图片保存到数据库，也不保存到项目目录下，而是保存到本地磁盘下，然后设置url路径和本地磁盘路径的映射，在Tomcat的conf/server.xml文件中进行配置

```txt
首先找到tomcat目录下conf目录下的server.xml文件，在server.xml文件中找到<Host></Host>；
然后在其中加上这<Context path="/uploadfile" docBase="D:\File\images"></Context>

上面配置完成后，tomcat在的请求一般为：http://localhost:8080/uploadfile/abc.jpg。配置完重启之后，该请求自动跳转到物理路径D:\File\image下查找。会访问本机的D:\File\imager\abc.jpg。
```

这样只需把数据库表中的，例如:path字段存储的相对路径值传到前端即可，前端把这个路径拼接到url上即可进行访问。**注意：这里设置的"Context path" 和application.yml里的不一样，访问图片是按照这个跟路径**

详见：工作个人笔记-2\项目笔记\tomcat配置虚拟路径上传文件、图片.docx  项目中图片的存储路径设置.docx 

后期写个例子验证

这样做的目的是减少数据库的容量，直接把图片保存到服务器的本地磁盘上了。

### 2，煤电平台保存图片也是按照 1 中的方法

数据库vehicles_imgs里只是保存的相对路径，共前端的url拼接后访问的

```html
<!--静态页面的路径-->
<img src = "/profile/upload/2021/08/21/ac6d94dd-4740-42e5-93a9-bc9f3a0911b4.jpg"></img>
访问路径：http://localhost:8080/profile/upload/2021/08/21/ac6d94dd-4740-42e5-93a9-bc9f3a0911b4.jpg
```

```java
//AppApiController.java里的上传图片方法 
private int uploadFiles(String foreignId,String serverType,String userId,List<MultipartFile> files){
        int num = 0;

        for(int i = 0 ; i < files.size() ; i++ ){
           try {
               String fileName = FileUploadUtils.upload(files.get(i));   //这里实际是真正上传图片到服务器
               VehiclesImgs vehiclesImgs = new VehiclesImgs();
               vehiclesImgs.setId(IdUtils.fastSimpleUUID());
               vehiclesImgs.setForeignId(foreignId);
               vehiclesImgs.setServerType(serverType);
               vehiclesImgs.setImgUrl(fileName);  //这里只是设置保存的相对路径，供前端访问用的
               vehiclesImgs.setCreateBy(userId);
               num += vehiclesImgsService.insertVehiclesImgs(vehiclesImgs);  //插入表内的只是路径字符串，并不是图片本身
           } catch (IOException e) {
               e.printStackTrace();
           }
       }

        return num;
    }
```

### 3, App端使用token认证的流程

(1)首先用户输入用户名密码验证通过后，会随机生成一个token, 它有个有效期，用户每次请求后端接口会在headers里带上这个token

详见：优车管postman登录app端步骤.docx

```java
//coal项目
@Controller
public class SysLoginController extends BaseController{
String token = IdUtils.fastSimpleUUID();
        user.setToken(token);
    return AjaxResult.success("登录成功",user);  //user含有token信息会传给前台
}    
```

(2)App端把后端传来的token保存到本地，每次请求就会带上这个token

![1645493354033](note-images/1645493354033.png)

(3)后端接收到这个token会在Filter里进行验证，对比与之前传过去的token是否相同，验证通过后才返回数据

```java
//coal项目
public class AppApiFilter  implements Filter {

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

        HttpServletRequest httpRequest = (HttpServletRequest)servletRequest;
        HttpServletResponse httpResponse = (HttpServletResponse)servletResponse;

        String mpToken = httpRequest.getHeader("mpToken");

        if(StringUtils.isEmpty(mpToken)){
            httpResponse.getWriter().println(JSONObject.valueAsStr(AjaxResult.error()));
        }else {
            Object obj = JedisUtils.getObject(mpToken);
            if(null != obj){
                filterChain.doFilter(httpRequest, httpResponse);
            }else {
                httpResponse.getWriter().println(JSONObject.valueAsStr(AjaxResult.error()));
            }
        }

    }

```

### 4, @RequestMapping注解也可以获取application.yml里的注入

```java
@Controller
@RequestMapping(value = "${adminPath}")  //这里在yaml文件中注入值
public class LoginController extends BaseController {   }
```

### 5, 页面图片小图展示的做法

设置好css样式即可，后期点击放大在加事件即可。

```html
<img src="http://localhost:8080/files/qq.jpg"  style="width:40px;height:40px;">图片QQ</img>  <br><br>

   <img src="http://localhost:8080/files/scenery.jpg" style="width:40px;height:40px;">风景</img>
```

### 6, 查看前端请求的后端接口地址

一般headers里有，如果headers里不对，则在Payload里可查看到

![1646187201545](note-images/1646187201545.png)

### 7,优车管App中token的用法

首先用户登陆后，后台会根据用户名等信息从数据库中查出用户全部信息；

然后生成一个uuid作为token, 把token当作key,  用户信息对象user当作value存到redis里；

把token返回前端；

本次会话访问接口都带着token，查询数据时就从redis里获取对应用户，再查该用户的的其它信息；

代码见:  coal 项目的SysLoginController.java   AppApiController.java

### 8, 使用HttpServletRequest接收上传的文件，并保存

![1646723639992](note-images/1646723639992.png)

```java
  //11,保存
    @ResponseBody
    @RequestMapping("/saveOrder")
    public ResultModel savePhoto(HttpServletRequest request) {

        ResultModel result = new ResultModel("0","测试");

        //新建CommonsMultipartResolver
        CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver(request.getSession().getServletContext());
        //上传文件地址
        String destPath = "E:\\localfile\\recycle";
        String imgPath = "";
        //判断请求里是否含有MultipartFile
        if (multipartResolver.isMultipart(request)) {
            //multiRequest是个Map,前端一个key对应一个multipart,传多个文件须有多个key, 名称不限，这里会自动解析
            MultipartHttpServletRequest multiRequest = (MultipartHttpServletRequest) request;
            Iterator<String> iter = multiRequest.getFileNames();
            //判断并保存到服务器本地
            while (iter.hasNext()) {
                MultipartFile multipartFile = multiRequest.getFile(iter.next());
                String dir = destPath + File.separator + multipartFile.getOriginalFilename();
                File file  = new File(dir);
                try {
                    multipartFile.transferTo(file);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
//        imgPath = imgPath.substring(0, imgPath.length() - 1);

        return result;
    }
```

### 9, SpringBoot项目设置访问图片路径映射

- **第一种方式：**

  编写一个WebMvcConfig类继承WebMvcConfigurerAdapter： 

addResourceHandler("/upload/**")配置的虚拟路径
 addResourceLocations(“file:D:/SchoolShop_IMG/upload/”);配置的映射路径 

注意：

1. file： 前缀不能丢。
2. 分隔符一定要用 / 。
3. 如果有配置server.servlet.context-path: /demo ，访问图片时一定要加上

```java
@Configuration
public class WebMvcConfig extends WebMvcConfigurerAdapter {
    @Autowired
    private FileUploadProperteis fileUploadProperteis;
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(fileUploadProperteis.getStaticAccessPath())
                .addResourceLocations("file:" + fileUploadProperteis.getUploadFolder() + "/");
    }

}
```

**注意：**上面设置后，原来SpringBoot项目默认设置resources目录静态路径static等都失效了，

需要在addResourceLocations(String ...)添加参数设置，使原先的static, public默认路径等还有效，因为它们里放着js,css等文件

```java
@Configuration
public class WebUrlMvcConfig extends WebMvcConfigurerAdapter {
    @Autowired
    private WebConfigProperties webConfigProperties;
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(webConfigProperties.getAccessPath())
                .addResourceLocations("file:" + webConfigProperties.getBaseDir() + "/" , "classpath:/static/","classpath:/public/");
    }
    //addResourceLocations(String ...),形参是可变参数，多个路径用逗号“，”隔开
}
```

- **第二种方式：再application.yml文件里设置**

https://blog.csdn.net/qq_31762741/article/details/121174900

```yml
# 应用服务 WEB 访问端口
server.port=8080
# 项目静态资源路径,可以不写默认为/**
# spring.mvc.static-path-pattern=/**
# 将项静态目资源路径映射到系统资源路径下
spring.resources.static-locations=file:H:\\AFile

====
spring.resources.static-locations=file:G:\\AFile,file:H:\\AFile

```

### 10, SpringBoot项目自定义配置类，出现异常

Web模块Application.java主启动类，启动报异常

异常名称：Error creating bean with name 'resourceHandlerMapping

代码：项目是SpringBoot多个模块

出错原因，这个个人手写配置类是给Weixin模块用的，但是开始放到了核心模块core里

解决办法：把这个自定义配置类放到Weixin模块即可

```java
//SpringBoot设置虚拟路径映射Tomcat磁盘路径
@Configuration
public class WebUrlMvcConfig extends WebMvcConfigurerAdapter {
    @Autowired
    private WebConfigProperties webConfigProperties;
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(webConfigProperties.getAccessPath())
                .addResourceLocations("file:" + webConfigProperties.getBaseDir() + "/");
    }
}
```

```yaml
file:
  enabled: true
  #url映射路径
  accessPath: /wxfiles/**
  #本地测试磁盘路径
  baseDir: E:\\localfile\\recycle
```

### 11,  idea使用maven可不设置Delegatge  IDE build/run  to Maven

执行 mvn  clean 以后 ，直接启动，反而可以自动编译，不用compile,  install了

### 12, “<“packaging>pom</packaging”>”的含义

一般在SpringBoot项目的根目录下的pom.xml里进行这样的设置

（1）打包成pom表示它生成的构件只是它本身， 没有代码需要测试或者编译，也没有资源需要处理。打包类型为POM的项目的默认目标 ；

（2） pom 项目里没有java代码，也不执行任何代码，只是为了聚合工程或传递依赖用的。

 （3） 配置<packaging>pom</packaging>的意思是使用maven分模块管理，都会有一个父级项目，pom文件一个重要的属性就是packaging（打包类型），一般来说所有的父级项目的packaging都为pom，packaging默认类型jar类型，如果不做配置，maven会将该项目打成jar包。  

### 13，Windows关闭端口号命令

netstat -ano | findstr 8080   ： 找到8080端口

taskkill -PID 9172 -F  ：终结进程

### 14,  SpringBoot手动开启事务代码范例

注意DataSourceTransactionManager的注解是@Resource

```java
@Service
public class YzDDateServiceImpl implements YzDDateService {

 
    @Resource
    private DataSourceTransactionManager transactionManager;
    
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);
  		transactionManager.commit(status);
    	transactionManager.rollBack(status);
```

### 15, 使用JSONObject把前台传来的json数组转为集合

使用的阿里巴巴的fastjson.JSONObject，此类中还有其它json字符串和java对象互转的方法

```java
    public Result<RecycleOrder> updateOrder(RecycleOrder recycleOrder,HttpServletRequest request){
        String subTypeAndPrice = request.getParameter("subTypeAndPrice");
        JSONObject jsonObject = new JSONObject();
        List<RecycleOrderCollection> rocList = jsonObject.parseArray(subTypeAndPrice,RecycleOrderCollection.class);
     
    }
```

### 16, Maven仓库设置冲突问题，pom.xml和settins.xml

如果pom.xml里设置了阿里云的远程仓库，那本地的 Maven—>conf/settings.xml里不要设置阿里云了，改为原来的默认仓库，且只写一个"<mirror>"；

### 17, idea项目修改代码，不必每次使用Maven  install解决方案

idea的Maven项目时，避免每次修改代码都得执行maven的install的解决方案

删除项目中的.idea文件，取消勾选idea中的 Maven -->Delegate IDE on maven，然后改代码后直接重启就行，修改会自动编译更新。

### 18, SpringBootApplication启动类的@MapperScan设置

```java
@ComponentScan("com.jeesite")
@ComponentScan("redis.clients.jedis")
 //如果xxxMapper.java在不同的包下，中间用"*",也可用“**”表示多重路径
@MapperScan("com.jeesite.modules.*.mapper") 
@SpringBootApplication
public class Application extends SpringBootServletInitializer {

}
```

### 19，项目使用lombok报假红，idea需下载lombok插件

<img src="note-images/1649683774938.png" alt="1649683774938" style="zoom:25%;" />

### 20，前端请求头的格式

Content-Type :  application/x-www-form-urlencoded   : 表示请求是表单格式的，一般网页用这种。

Content-Type : application/json : 请求是json对象格式的，一般 app, 小程序等用这种格式，例：

```json
{
  "id": "e511a532298a4fa69413dc4c0353df90",
  "pageNo": 1,
  "pageSize": 2,
  "orderType": "1"
}
```

### 21，控制层接收JSON数据格式，使用注解@RequestBody,  @RestController

（1）单个方法接收json使用@RequestBody

```java
	@RequestMapping(value="/mySum",method = {RequestMethod.POST})
    @ResponseBody
    public RecycleSeller getMySum(@RequestBody RecycleSeller recycleSeller){
        return recycleSellerService.getMySum(recycleSeller);
    }
```

（2）设置整个控制层方法接收JSON数据格式，使用注解@RestController(=@Controller + @RequestBody)

```java
 @Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Controller
 @ResponseBody
public @interface RestController
/**
 A convenience annotation that is itself annotated with @Controller and @ResponseBody.
Types that carry this annotation are treated as controllers where @RequestMapping methods assume @ResponseBody semantics by default.
*/
```

### 22，MyBatis存"if test=  updateTime !='' " 日期报错

错误：

```txt
Cause: java.lang.IllegalArgumentException: invalid comparison: java.util.Date and java.lang.String
```

原因：

```xml
<update id="updateTo" parameterType="RecycleUserOrder">
		UPDATE recycle_user_order
		<trim prefix="SET"  suffixOverrides=",">
			<if test="buyerId != null and buyerId != ''">
				buyer_id = #{buyerId},
			</if>
			<if test="userId != null and userId != ''">
				user_id = #{userId},
			</if>
 <!--这里“updateTime !=''”报错，MyBatis中日期类不能用空字符''判断，会把日期转成String,引起格式错误--> 
			<if test="updateTime != null and updateTime !='' "> 
				update_time = #{updateTime},
			</if>
		</trim>
		WHERE order_id = #{orderId}
	</update>
```

### 23，底层到上层

 电路学->模电->数电->汇编->操作系统 

算法常用的就十几种，不神秘，不高大上。

### 24，@MapperScan用法

在使用JeeSite框架时，须在启动类上加上@MapperScan注解，表明xxxDao.java所在的包，不加项目启动时扫描不到，出现“UnsatisfiedDependencyException”无法注入异常

```java
@SpringBootApplication
@MapperScan("com.jeesite.weixin.dao")
public class WeixinApplication extends SpringBootServletInitializer {
    public static void main(String[] args) {
        SpringApplication.run(WeixinApplication.class, args);
    }
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        this.setRegisterErrorPageFilter(false); // 错误页面有容器来处理，而不是SpringBoot
        return builder.sources(WeixinApplication.class);
    }
}
```

### 25，数据库表一对一的使用场景

例如，文章的ID放到一张表，文章的详情放到一张表，通过ID形成一对一，目的是减少负载；

如果文章ID和内容都放到一张表，展示的时候把ID和内容一起查出来，那么大量用户访问时会造成单表负载过大。两张表分开，第一张表显示文章的ID，标题，作者等概要信息，第二张表显示文章的详细内容，通过id形成一对一关联，可减少负载，优化查询。

同样的电商项目的商品列表和商品详情表也是用的一对一的关系

代码范例：

- 获取数据：

![1650681791288](note-images/1650681791288.png)

Article.java对应的是文章表，ArticleData.java对应的是文章详情表，它们的id是一样的，上面重写get方法，通过判断article_data详情表里是否有锁查询的article的id，有则调用  ArticleData  get(articleData)方法获取文章详情，并把articleData即文章内容赋值给Article.java里的articleData对象。

public Article get(Article  article)实际是查了两次数据库。

- 保存数据：在ArticleService.java里保存article之后，还要保存articleData文章内容

![1650682858702](note-images/1650682858702.png)

### 26，树状结构和节点对应表的对应关系

article表中的classify_id就是article_classify_tree表中的type_code

文章内容表：

```sql
CREATE TABLE `article` (
  `id` varchar(64) NOT NULL,
  `classify_id` varchar(64) DEFAULT NULL COMMENT '分类id',
  `classify_name` varchar(255) DEFAULT NULL COMMENT '分类名称',
  `title` varchar(255) DEFAULT NULL COMMENT '文章标题',
  `author` varchar(64) DEFAULT NULL COMMENT '作者',
  `author_head_pic` varchar(255) DEFAULT NULL COMMENT '作者头像',
  `href` varchar(255) DEFAULT NULL COMMENT '外部链接',
  `image` varchar(1000) DEFAULT NULL COMMENT '列表图片',
  `remark` varchar(1000) DEFAULT NULL COMMENT '列表简要描述',
  `content` longtext COMMENT '文章内容',
  `reference` varchar(100) DEFAULT NULL COMMENT '出处',
  `disease` varchar(20) DEFAULT NULL COMMENT '病种',
  `source` varchar(20) DEFAULT NULL COMMENT '来源（转载/原创）',
  `hits` varchar(64) DEFAULT NULL COMMENT '点击数',
  `hits_plus` varchar(64) DEFAULT NULL COMMENT '点赞数',
  `word_count` varchar(255) DEFAULT NULL COMMENT '文章字数',
  `status` varchar(1) DEFAULT NULL COMMENT '状态（0正常 1删除 2 停用 3冻结 4 待审 5驳回 9草稿 )',
  `create_by` varchar(64) DEFAULT NULL COMMENT '创建者',
  `create_date` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(64) DEFAULT NULL COMMENT '更新者',
  `update_date` datetime DEFAULT NULL COMMENT '更新时间',
  `user_code` varchar(64) DEFAULT NULL COMMENT '医馆账号编码',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='文章表';
```

树状表

```sql
CREATE TABLE `article_classify_tree` (
  `type_code` varchar(64) NOT NULL COMMENT '分类编号',
  `parent_code` varchar(64) DEFAULT NULL COMMENT '父级编号',
  `parent_codes` varchar(1000) DEFAULT NULL COMMENT '所有父级编号',
  `tree_sort` decimal(10,0) DEFAULT NULL COMMENT '本级排序号',
  `tree_sorts` varchar(1000) DEFAULT NULL COMMENT '所有级别排序号',
  `tree_leaf` char(1) DEFAULT NULL COMMENT '是否最末级',
  `tree_level` decimal(4,0) DEFAULT NULL COMMENT '层次级别',
  `tree_names` varchar(1000) DEFAULT NULL COMMENT '全节点名',
  `type_name` varchar(255) DEFAULT NULL COMMENT '分类名称',
  `image` varchar(255) DEFAULT NULL COMMENT '图片',
  `href` varchar(255) DEFAULT NULL COMMENT '链接',
  `status` varchar(10) DEFAULT NULL COMMENT '状态（0正常 1删除 2停用）',
  `create_by` varchar(64) DEFAULT NULL,
  `create_date` datetime DEFAULT NULL,
  `update_by` varchar(64) DEFAULT NULL,
  `update_date` datetime DEFAULT NULL,
  PRIMARY KEY (`type_code`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='文章分类树状表';
```

### 27，云服务器设置开放端口

主机系统设置好后，注意在网页阿里云账户里也要开放端口









